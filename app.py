#!/usr/bin/env python3
"""
AdvAI Image Generator Web Application
Flask backend server for Vercel deployment
"""

import os
import asyncio
import logging
import uuid
from datetime import datetime
from typing import List, Dict, Any, Optional

# Import config for API keys with fallback
try:
    from config import POLLINATIONS_KEY
except ImportError:
    # Fallback for Vercel deployment - get from environment variables
    POLLINATIONS_KEY = os.environ.get('POLLINATIONS_KEY', '')

from flask import Flask, request, jsonify, Response
from flask_cors import CORS

# Import g4f directly
try:
    import g4f
    from g4f.client import Client as GPTClient, AsyncClient
    from g4f.Provider import PollinationsImage
    G4F_AVAILABLE = True
except ImportError:
    G4F_AVAILABLE = False

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Configuration for Vercel
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024


def generate_ai_response(prompt: str, model: str = "gpt-4o") -> str:
    """Generate AI response using g4f GPTClient"""
    if not G4F_AVAILABLE:
        raise Exception("g4f library not available")
    
    if not POLLINATIONS_KEY:
        raise Exception("POLLINATIONS_KEY not configured")
    
    try:
        gpt_client = GPTClient()
        history = [{"role": "user", "content": prompt}]
        
        response = gpt_client.chat.completions.create(
            api_key=POLLINATIONS_KEY,
            model=model,
            messages=history,
            provider="PollinationsAI"
        )
        return response.choices[0].message.content
    except Exception as e:
        logger.error(f"Error generating AI response: {e}")
        raise

async def generate_images_standalone(prompt: str, style: str = None, max_images: int = 1, width: int = 1024, height: int = 1024, model: str = "flux") -> tuple:
    """Generate images using g4f directly"""
    if not G4F_AVAILABLE:
        return [], "g4f library not available"
    
    if not POLLINATIONS_KEY:
        return [], "API key not configured"
    
    try:
        # Style definitions
        style_definitions = {
            "default": {"prompt_additions": "ultra realistic, detailed, photographic quality"},
            "photorealistic": {"prompt_additions": "photorealistic, ultra realistic, detailed, professional photography"},
            "artistic": {"prompt_additions": "artistic, creative, expressive, painterly style"},
            "anime": {"prompt_additions": "anime style, manga style, vibrant colors"},
            "cartoon": {"prompt_additions": "cartoon style, animated, colorful, stylized"},
            "digital-art": {"prompt_additions": "digital art, concept art, trending on artstation"},
            "painting": {"prompt_additions": "oil painting, traditional art, brushstrokes, artistic"},
            "sketch": {"prompt_additions": "pencil sketch, hand drawn, artistic sketch, detailed drawing"}
        }
        
        # Get style info and enhance prompt
        style_info = style_definitions.get(style or "default", style_definitions["default"])
        enhanced_prompt = f"{prompt}, {style_info['prompt_additions']}"
        
        logger.info(f"Generating {max_images} images with enhanced prompt: {enhanced_prompt[:100]}...")
        
        # Use AsyncClient with PollinationsImage provider
        async_client = AsyncClient(image_provider=PollinationsImage, api_key=POLLINATIONS_KEY)
        
        # Generate images
        response = await async_client.images.generate(
            prompt=enhanced_prompt,
            model=model,
            response_format="url",
            width=width,
            height=height,
            n=max_images,
        )
        
        # Check if response is valid
        if not response or not hasattr(response, 'data') or not response.data:
            logger.warning("No image data returned from API")
            return [], "No images were generated by the AI service"
        
        # Extract URLs from response
        image_urls_list = []
        for i, image_object in enumerate(response.data):
            if hasattr(image_object, 'url') and image_object.url and image_object.url.startswith("https://"):
                image_urls_list.append(image_object.url)
                logger.info(f"Generated image {i+1}: {image_object.url}")
            else:
                logger.warning(f"Image object {i} has no valid HTTPS URL. Skipping.")
        
        if image_urls_list:
            logger.info(f"Successfully generated {len(image_urls_list)} images")
            return image_urls_list, None
        else:
            logger.error("No valid image URLs were returned")
            return [], "No valid images were generated"
        
    except Exception as e:
        logger.error(f"Error in generate_images_standalone: {e}")
        return [], f"Image generation failed: {str(e)}"

def clean_prompt(prompt: str, style: str = 'default') -> str:
    """Clean and enhance the prompt based on style"""
    prompt = prompt.strip()
    
    # Style-specific enhancements
    style_prefixes = {
        'photorealistic': 'photorealistic, highly detailed, professional photography, ',
        'artistic': 'artistic, creative, expressive, ',
        'anime': 'anime style, manga style, ',
        'cartoon': 'cartoon style, animated, colorful, ',
        'digital-art': 'digital art, concept art, trending on artstation, ',
        'painting': 'oil painting, traditional art, brushstrokes, ',
        'sketch': 'pencil sketch, hand drawn, artistic sketch, '
    }
    
    if style in style_prefixes:
        prompt = style_prefixes[style] + prompt
    
    # Add quality enhancers
    quality_suffix = ', high quality, detailed, 4k resolution'
    if not any(term in prompt.lower() for term in ['quality', 'detailed', '4k', 'hd']):
        prompt += quality_suffix
    
    return prompt

# HTML content as string to avoid file reading issues in serverless
INDEX_HTML = '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdvAI Image Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 10px; max-width: 600px; margin: 0 auto; }
        .status { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .form-group { margin: 20px 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        textarea, select, input { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
        button { background: #007bff; color: white; padding: 12px 24px; border: none; border-radius: 5px; cursor: pointer; margin: 10px 5px 10px 0; }
        button:hover { background: #0056b3; }
        .generated-image { margin: 20px 0; text-align: center; }
        .generated-image img { max-width: 100%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .loading { display: none; text-align: center; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ AdvAI Image Generator</h1>
        <div class="status">
            âœ… Serverless deployment working!
        </div>
        
        <div class="form-group">
            <label for="prompt">Image Description:</label>
            <textarea id="prompt" placeholder="Describe the image you want to generate..." rows="3"></textarea>
        </div>
        
        <div class="form-group">
            <label for="style">Style:</label>
            <select id="style">
                <option value="default">Default</option>
                <option value="photorealistic">Photorealistic</option>
                <option value="artistic">Artistic</option>
                <option value="anime">Anime</option>
                <option value="cartoon">Cartoon</option>
                <option value="digital-art">Digital Art</option>
                <option value="painting">Painting</option>
                <option value="sketch">Sketch</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="size">Image Size:</label>
            <select id="size">
                <option value="1024x1024">Square (1024Ã—1024)</option>
                <option value="1536x1024">Wide (1536Ã—1024)</option>
                <option value="1024x1536">Tall (1024Ã—1536)</option>
                <option value="512x512">Small (512Ã—512)</option>
            </select>
        </div>
        
        <button onclick="generateImage()">ðŸŽ¨ Generate Image</button>
        <button onclick="enhancePrompt()">âœ¨ Enhance Prompt</button>
        
        <div id="loading" class="loading">
            <p>ðŸ”„ Generating your image...</p>
        </div>
        
        <div id="result"></div>
        
        <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; text-align: center; color: #666;">
            <p>Powered by AdvAI â€¢ <a href="/api/health">API Status</a></p>
        </div>
    </div>

    <script>
        async function generateImage() {
            const prompt = document.getElementById('prompt').value.trim();
            const style = document.getElementById('style').value;
            const size = document.getElementById('size').value;
            
            if (!prompt) {
                alert('Please enter an image description');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('result').innerHTML = '';
            
            try {
                const formData = new FormData();
                formData.append('description', prompt);
                formData.append('style', style);
                formData.append('size', size);
                formData.append('variants', '1');
                formData.append('model', 'flux');
                
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success && data.images && data.images.length > 0) {
                    const imageUrl = data.images[0].url;
                    document.getElementById('result').innerHTML = 
                        '<div class="generated-image"><img src="' + imageUrl + '" alt="Generated Image"><br><a href="' + imageUrl + '" target="_blank">Open Full Size</a></div>';
                } else {
                    document.getElementById('result').innerHTML = 
                        '<div class="error">Error: ' + (data.error || 'Failed to generate image') + '</div>';
                }
            } catch (error) {
                document.getElementById('result').innerHTML = 
                    '<div class="error">Error: ' + error.message + '</div>';
            }
            
            document.getElementById('loading').style.display = 'none';
        }
        
        async function enhancePrompt() {
            const prompt = document.getElementById('prompt').value.trim();
            
            if (!prompt) {
                alert('Please enter a prompt to enhance');
                return;
            }
            
            try {
                const response = await fetch('/api/enhance-prompt', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt })
                });
                
                const data = await response.json();
                
                if (data.enhanced_prompt) {
                    document.getElementById('prompt').value = data.enhanced_prompt;
                } else {
                    alert('Error: ' + (data.error || 'Failed to enhance prompt'));
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    </script>
</body>
</html>'''

@app.route('/')
def index():
    """Serve the main page"""
    return Response(INDEX_HTML, mimetype='text/html')

@app.route('/api/enhance-prompt', methods=['POST'])
def enhance_prompt():
    """Enhance a user prompt using AI"""
    try:
        data = request.get_json()
        original_prompt = data.get('prompt', '').strip()
        
        if not original_prompt:
            return jsonify({'error': 'Prompt is required'}), 400
        
        if len(original_prompt) > 500:
            return jsonify({'error': 'Prompt is too long'}), 400
        
        # AI prompt enhancement
        enhancement_prompt = f"""
        Enhance this image prompt to be more detailed and vivid: "{original_prompt}"
        
        Make it more descriptive with artistic details, lighting, and mood. Keep it under 400 characters.
        
        Enhanced prompt:"""
        
        try:
            enhanced = generate_ai_response(enhancement_prompt)
            
            # Clean up the response
            enhanced = enhanced.strip()
            if enhanced.startswith('"') and enhanced.endswith('"'):
                enhanced = enhanced[1:-1]
            
            # Ensure it's not too long
            if len(enhanced) > 500:
                enhanced = enhanced[:497] + "..."
            
            return jsonify({
                'original_prompt': original_prompt,
                'enhanced_prompt': enhanced
            })
            
        except Exception as e:
            logger.error(f"Error enhancing prompt with AI: {e}")
            # Fallback enhancement
            enhanced = f"detailed, high quality, {original_prompt}, professional lighting, stunning composition"
            return jsonify({
                'original_prompt': original_prompt,
                'enhanced_prompt': enhanced
            })
        
    except Exception as e:
        logger.error(f"Error in enhance_prompt: {e}")
        return jsonify({'error': 'Failed to enhance prompt'}), 500

@app.route('/api/generate', methods=['POST'])
def generate_images_api():
    """Generate images based on prompt and settings"""
    try:
        # Get form data
        description = request.form.get('description', '').strip()
        size = request.form.get('size', '1024x1024')
        variants = int(request.form.get('variants', 1))
        style = request.form.get('style', 'default')
        model = request.form.get('model', 'flux')
        
        # Validate input
        if not description:
            return jsonify({'error': 'Description is required'}), 400
        
        if len(description) > 500:
            return jsonify({'error': 'Description is too long (max 500 characters)'}), 400
        
        if variants not in [1, 2, 4]:
            return jsonify({'error': 'Invalid number of variants'}), 400
        
        # Parse width and height from size string
        try:
            width, height = map(int, size.split('x'))
            if width < 256 or height < 256 or width > 2048 or height > 2048:
                return jsonify({'error': 'Invalid image dimensions'}), 400
        except ValueError:
            return jsonify({'error': 'Invalid image size format'}), 400
        
        # Clean and enhance the prompt
        enhanced_prompt = clean_prompt(description, style)
        
        logger.info(f"Generating {variants} image(s) with prompt: {enhanced_prompt}")
        
        # Generate images using standalone function
        try:
            generated_urls, error = asyncio.run(generate_images_standalone(
                prompt=enhanced_prompt,
                style=style if style != 'default' else None,
                max_images=variants,
                width=width,
                height=height,
                model=model
            ))
            
            if error:
                logger.error(f"Image generation error: {error}")
                return jsonify({'error': f'Image generation failed: {error}'}), 500
            
            if not generated_urls:
                logger.error("No images generated")
                return jsonify({'error': 'No images were generated'}), 500
            
            # Format response
            images = []
            for i, url in enumerate(generated_urls):
                images.append({
                    'url': url,
                    'id': f"{uuid.uuid4().hex}",
                    'prompt': enhanced_prompt,
                    'size': size,
                    'style': style,
                    'model': model,
                    'index': i
                })
            
            return jsonify({
                'success': True,
                'images': images,
                'prompt': enhanced_prompt,
                'original_prompt': description,
                'settings': {
                    'size': size,
                    'variants': variants,
                    'style': style,
                    'model': model
                }
            })
            
        except Exception as e:
            logger.error(f"Error generating images: {e}")
            return jsonify({'error': 'Image generation service temporarily unavailable'}), 500
        
    except Exception as e:
        logger.error(f"Unexpected error in generate_images_api: {e}")
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'service': 'AdvAI Image Generator',
        'timestamp': datetime.now().isoformat(),
        'g4f_available': G4F_AVAILABLE,
        'api_key_configured': bool(POLLINATIONS_KEY)
    })

@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors"""
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    logger.error(f"Internal server error: {error}")
    return jsonify({'error': 'Internal server error'}), 500

# For Vercel serverless deployment
if __name__ == '__main__':
    # Local development
    app.run(debug=True, host='0.0.0.0', port=int(os.environ.get('PORT', 5000))) 